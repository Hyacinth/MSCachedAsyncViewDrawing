{"tagline":"Helper class that allows you to draw views (a)synchronously to a UIImage with caching for great performance.","body":"# MSCachedAsyncViewDrawing\r\n\r\nHelper class that allows you to draw views (a)synchronously to a UIImage with caching for great performance.\r\n\r\n## Description\r\n\r\n(This assumes you know a bit about CoreGraphics and how some things like blending work. If not, go read [this post](http://engineering.twitter.com/2012/02/simple-strategies-for-smooth-animation.html) in the Twitter Engineering Blog).\r\n\r\nSo you have a UITableView in your application that scrolls slow. You decide to implement the cell drawing entirely in CoreGraphics implementing ```-[UIView drawRect:]``` in your cell. This is perfect, until you have to draw images. ```CGContextDrawImage``` is **really slow** compared to using ```UIImageView```.\r\n\r\nFor this reason, many times you'll find yourself preferring to use ```UIImageView``` even if some compositing has to happen on the cell, because rendering images with it is **FAST** due to the crazy optimizations that it implements internally.\r\n\r\nBut sometimes you do have to use ```CGContextDrawImage```, because you have to do something more complex like masking, clipping, etc. Wouldn't it be great if you could still do that, but pass the result to a ```UIImageView``` easily, so that you get the benefit from both worlds? That's what ```MSCachedAsyncViewDrawing``` does.\r\n\r\n## When to use MSCachedAsyncViewDrawing\r\nNeedless to say you shouldn't just go ahead and apply this to all of the UIViews in your app. There's a drawback in this approach, as you're incurring in higher memory usage by storing the result of the all the drawing operations.\r\n**The only way to know if using `MSCachedAsyncViewDrawing` improves or not the performance in your particular case, is to try it out and compare.**\r\nAs a general rule on when *it makes sense* to use it would be when -`drawRect:` is becoming a bottleneck, specially if it's using `CGContextDrawImage` inside. This can happen when you have many complex views in the cells of a `UITableView`.\r\n\r\n## Sample Project\r\n\r\nThe sample project contains two view controllers that contain a table view in which every row has 3 views that implement `-drawInRect:`. One of them uses ```MSCachedAsyncViewDrawing``` and the other one doesn't. This is an example on how to use this class and its performance benefit. Install the sample app on your iOS device and compare.\r\nIt's also a typical use case for this class, since there are many views on screen at the same time, and they all have to render a `UIImage`, this becomes a bottleneck. `MSCachedAsyncViewDrawing` makes this asynchronous, hence not blocking the main thread and getting perfect scrolling performance, and it also prevents the views from rendering more than once.\r\n\r\n## How to use it\r\n\r\nThis is the main method in ```MSCachedAsyncViewDrawing```:\r\n\r\n```objc\r\n- (void)drawViewAsyncWithCacheKey:(NSString *)cacheKey\r\n                             size:(CGSize)imageSize\r\n                  backgroundColor:(UIColor *)backgroundColor\r\n                        drawBlock:(MSCachedAsyncViewDrawingDrawBlock)drawBlock\r\n                  completionBlock:(MSCachedAsyncViewDrawingCompletionBlock)completionBlock;\r\n```\r\n\r\nThe block types are declared like this:\r\n\r\n```objc\r\ntypedef void (^MSCachedAsyncViewDrawingDrawBlock)(CGRect frame);\r\ntypedef void (^MSCachedAsyncViewDrawingCompletionBlock)(UIImage *drawnImage);\r\n```\r\n\r\n```MSCachedAsyncViewDrawing``` is going to take the `drawBlock` and call it on a background thread, passing it the `CGRect` that you can pass to a `-drawRect:` method of a view. When it's done, it's going to cache the `UIImage` object with the specified `cacheKey` and call your `completionBlock` with it.\r\n\r\nA subsequent call with the same `cacheKey` will result in the immediate call of the `completionBlock` without calling the drawBlock because it'll grab the rendered image from the cache.\r\n\r\nThe cache is implemented using `NSCache`, so you don't have to worry about putting caching too many images, because iOS is going to take care of evicting obejcts as the available memory goes low.\r\n\r\nIf you prefer to block the UI while the rendering is happening, beacuse you want to make sure that the image view is not empty at any point, you can use this other method, which inmediately returns the ```UIImage``` object:\r\n\r\n```objc\r\n- (UIImage *)drawViewSyncWithCacheKey:(NSString *)cacheKey\r\n                                 size:(CGSize)imageSize\r\n                      backgroundColor:(UIColor *)backgroundColor\r\n                            drawBlock:(MSCachedAsyncViewDrawingDrawBlock)drawBlock;\r\n```\r\n\r\n\r\n## Compatibility\r\n- ```MSCachedAsyncViewDrawing``` is compatible with iOS5.0+.\r\n- ```MSCachedAsyncViewDrawing``` uses ARC. To use in a non-ARC project, mark ```MSCachedAsyncViewDrawing.m``` with the linker flag ```-fobjc-arc.```\r\n\r\n## License\r\n\r\nCopyright 2012 MindSnacks\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.","name":"MSCachedAsyncViewDrawing","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}